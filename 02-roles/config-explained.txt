Example node configuration

All nodes run same program. However, semantically we can classify nodes into
three categories:
- external input node - node that simulate events from "other" applications that
  communicate with "our" through message queue (rabbitmq)
- internal processing node - node that wait for a message or generate one or
  do something; as a result it may send a message to some queue(s),
  or to a file (e.g. simulating database access)
- external output node - node that simulate "other" apps that read messages from
  some queue ("consumes" messages generated by "our" app)

Node behavior is described with three elements:
1. how it gets its "data" (queue or generate one)
2. how it process its "data" (duration, transformation on data) into "result"
3. where it saves its "result" (if there is one)

Example system:
- five nodes communicating in pattern:
EXT-in-1 -> {ex-1->q1} -> {Node-1 + Node-2} -> {ex2->q2} -> EXT-out-1 (print)
            {ex-1->q3} -> Node-3 (log)         {ex2->q3} -> Node-3 (log)

Two exchanges are used "ex-1" and "ex-2" of fanout type.
Three queues are bound to this exchanges, as depicted above:
q1 and q3 to ex-1, q2 and q3 to ex-2 (q3 is bound to both of them).

Flags for exchanges/queues:
- exclusive=False - more consumer can wait on the same queue
- durable=True - save messages on interrupt/shutdown?
- prefetch_count=1 - only single msg to single consumer until it confirms its consumed
- auto_ack=False - consumer must confirm msg receipt (and processing)

Nodes EXT-in-1 and EXT-out-1 simulate other applications.
Nodes Node-1 to Node-3 are part of our application.
Node-1 and Node-2 wait on q1 and when message arrives one of them process it (only one).
Node-3 gets a copy of outgoing message (e.g. for logging).

Configuration is saved into config.json.
Its more or less self explanatory.
